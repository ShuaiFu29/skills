# Vue3 所采用的 Composition API 与 Vue2 使用的 Options API 有什么区别？

- 开始之前
  Compsition API 可以说是 Vue3 的最大特点，那么为什么要推出 Composition API，解决了什么问题？
  通常使用 Vue2 开发的项目，普遍会存在以下问题
  - 代码的可读性随着组件变大而变差
  - 每一种代码复用的方式都存在缺点
  - TypeScript 支持有限
    以上通过 Composition API 都能迎刃而解
- Options API
  选项 API，即以 vue 为后缀的文件，通过定义 methods，computed，watch，data 等属性与方法，共同处理页面逻辑。然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解
- Composition API
  在 vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）
  即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API
- Composition API 与 Options API 对比
  - 逻辑组织
    Options API，假设一个组件是一个大型组件，其内部有很多逻辑关注点，这种碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块
    Composition API，正是解决上述问题，将某个逻辑关注点相关代码全部都放在一个函数里，这样需要修改一个功能时，就不需要在文件里跳来跳去
  - 逻辑复用
    整个数据来源清晰，即使编写更多的 hook 函数，也不会出现命名冲突的问题
- 小结
  - 在逻辑组件和逻辑复用方面，Composition API 是由于 Options API
  - 因为 Composition API 几乎是函数，会有更好的类型判断
  - Composition API 对 tree-shaking 友好，代码也更容易压缩
  - Composition API 中见不到 this 的使用，减少了 this 指向不明的情况
  - 如果是小型组件，可以继续使用 Options API，也是十分友好的

# vue3 的设计目标是什么？做了哪些优化？

- 设计目标
  vue3 之前也许会面临的问题
  - 随着功能增长，复杂组件的代码会变得越来越难以维护
  - 缺少一种比较干净的在多个组件之间提取和复用逻辑的机制
  - 类型推断不够友好
  - bundle 的时间太久了
    vue3 做了
  - 更小
  - 更快
  - TypeScript 支持
  - API 设计一致性
  - 提高自身可维护性
  - 开发更多底层功能
    一句话来说就是更小更快更友好了
    更小：移除了一些不常用的 API，引入 tree-shaking，可以将无用模块“剪辑”，仅打包需要的，使打包体积变小了
    更快：主要体现在编译方面：diff 算法优化，静态提升，事件监听缓存，SSR 优化
    更友好：vue3 在兼顾 vue2 的 options API 的同时还推出了 composition API ，大大增加了代码的逻辑组织和代码复用能力
- 优化方案
  vue3 从很多层面都做了优化，可以分为三个方面：
  - 源码
    - 源码管理
      vue3 整个源码是通过 monorepo 的方式维护的，根据功能将不同的模块拆分到 packages 目录下面不同的子目录中，这样使得模块拆分更细化，职责划分更明确，模块之间依赖关系更明确，开发人员也更容易阅读，理解，和更改模块源码，提高了代码的可维护性
    - TypeScript
      vue3 是基于 TypeScript 编写的，提供了更好的类型检查，能支持复杂的类型推导
  - 性能
    - 体积优化
    - 编译优化
    - 数据劫持优化
  - 语法 API
    - 优化逻辑组织
    - 优化逻辑复用

# vue3 性能提升主要是通过哪几方面体现的？

- 编译阶段
  回顾 vue2，我们知道每个组件实例都对应一个 watch 实例，它会在组件渲染的过程中把用到的数据 property 记录为依赖，当依赖发送改变，触发 setter，则会通知 watcher，从而使关联的组件重新渲染
  vue3 在编译阶段，做了进一步优化。主要有：
  - diff 算法优化
    vue3 在 diff 算法中相比 vue2 增加了静态标记。关于这个静态标记，其作用是为了会发送变化的地方添加一个 flag 标记，下次发生变化的时候之间找该地方进行比较
  - 静态提升
    vue3 中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接使用
    这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行的时候的内存占用
  - 事件监听缓存
    默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化
  - SSR 优化
    当静态内容大到一定量级的时候，会用 createStaticVNode 方法在客户端去生成一个 static node，这些静态 node，会被直接 innerHTML 用，就不需要创建对象，然后根据对象渲染
